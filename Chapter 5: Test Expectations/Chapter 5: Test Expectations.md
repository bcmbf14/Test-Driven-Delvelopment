# Chapter 5: Test Expectations
이전 챕터에서는 사용자가 시작 단추로 수행할 수 있는 작업에 기반하여 앱의 상태를 작성하셨습니다. 앱의 주요 부분은 사용자가 이동하면서 단계를 기록함에 따라 변화에 대응하는 것에 의존한다. 이러한 작용은 프로그램 통제 밖에서 이벤트를 생성한다. XCTestExpectation은 직접 흐름 밖에서 일어나는 일들을 테스트하는 도구다.

![image](https://user-images.githubusercontent.com/60660894/86639957-caa65a00-c014-11ea-9fd3-0562ab045dd8.png)

```swift
func expectTextChange() -> XCTestExpectation { return keyValueObservingExpectation(
for: sut.startButton as Any,
keyPath: "titleLabel.text") 
}
```

이 챕터에서는 다음을 알아보십시오.

• 일반적인 테스트 기대치
• 통지 기대치

이전 장의 결승전에서 계속 진행하지 말고 이 장의 스타터 프로젝트를 사용하십시오.


Using an expectation
XCTest expectation는 expectation waiter의 두 부분으로 나뉜다. 기대는 나중에 성취할 수 있는 대상이다. XCTestCase의 wait 메소드는 기대치가 충족되거나 지정된 시간이 경과할 때까지 기다리도록 테스트 실행을 지시한다.
마지막 장에서 직접 사용자 작업에 해당하는 앱 상태(진행 중, 일시 중지 중, 시작되지 않음)를 작성하셨습니다. 이 챕터에서는 잡히고 완료되는 것에 대한 지원을 추가하십시오.

이러한 상태 전환은 사용자가 통제할 수 없는 비동기 이벤트에 대응하여 발생한다.
붉은 그늘이 드리워진 주들은 이미 건설되었다. 회색 주(州)를 추가하게 될 거야


Wri7ng an asynchronous test
비동기 이벤트에 반응하기 위해서, 코드는 변화를 들을 수 있는 방법이 필요하다. 이는 일반적으로 폐쇄, 위임 방법 또는 통지 관찰을 통해 이루어진다.
AppModel에서 비동기적으로 업데이트되는 포착 및 완료된 상태 변경을 테스트하려면 콜백 클로져를 추가하십시오. 첫 번째 단계는 시험을 쓰는 것이다!
AppModelTests.swift를 열고 // MARK: - 상태 변경:
이 테스트는 sut.pause를 사용하여 appState를 업데이트한 다음 stateChangedCallback이 트리거되는지 확인하고 watchedState를 새 값으로 설정하십시오. 이 테스트에서 몇 가지 새로운 항목을 사용하고 있는 경우:

1. 기대(설명:)는 XCTestExpectation 객체를 생성하는 XCTestCase 방법이다. 이 설명은 테스트 로그에서 고장을 식별하는 데 도움이 된다. 기대치가 달성되었는지 여부와 달성 시기를 추적하기 위해 얼마나 기대치가 사용되는지 곧 알게 될 것이다.

2. 이행은 이행되었다는 것을 나타내기 위해, 특히 콜백(callback)이 발생했음을 나타내기 위해 요구된다. 여기서 stateChangedCallback은 상태 변경이 발생할 때 sut에 트리거한다.

3. wait(pair:pair:)는 모든 기대가 충족되거나 시간 초과 시간(초 단위)이 경과할 때까지 시험 주자를 정지시킨다. 그 주장은 기다림이 끝날 때까지 호출되지 않을 것이다.

stateChangedCallback이 아직 존재하지 않기 때문에 테스트는 컴파일되지 않을 것이다. AppModel.swift에서 다음 항목을 클래스에 추가하십시오.
`이 속성을 추가하면 테스트가 구축될 수 있다. 이제 실행해보면 다음과 같은 것을 볼 수 있을 것이다.
콘솔 오류:

기대치가 달성되지 않아 1초 대기 시간 초과 후 테스트가 실패하였다. 이 문제를 해결하려면 AppModel에서 appState를 다음 항목과 일치하도록 변경하십시오.
이제 콜백은 AppState가 설정될 때마다 트리거된다.
AppModelTests.swift로 돌아가서 콜백 참조를 삭제하려면
분해의 맨 위로 이동: 
테스트를 다시 실행하면 이제 합격!

참고: 항상 완료 블록에서 이행 호출을 수행한 다음 대기 후 XCTAssert를 사용하여 오류 또는 기타 부정적인 조건을 테스트하는 것이 모범 사례. 타임아웃은 테스트에 상당한 시간을 추가하므로 테스트 실패를 알리는 데 사용해서는 안 된다.


Testing for true asynchronicity
마지막 테스트는 봉합에 대한 업데이트에 대한 직접적인 응답으로 콜백이 호출되는지 점검한다. 다음으로, 뷰 컨트롤러 업데이트를 통해 간접적인 사용을 해결하십시오. // MARK 끝의 StepCountControllerTests.swift에서 - 터미널 상태는 다음 두 가지 테스트를 추가한다.
이러한 테스트는 startButton 제목을 준수하여 모델 상태가 변경된 후 올바르게 업데이트되는지 확인한다.
sut.startButton의 textLabel이 업데이트되면 watch(_:기대:)가 전달된 기대치(확대)를 충족시킬 것이다. 이 작업을 수행하려면 ButtonObserver 도우미 클래스가 필요하며, 이 클래스를 만들려는 경우!
테스트 클래스 그룹에 새 Swift 파일을 추가하고 이름을 ButtonObserver.swift로 지정하십시오. 파일에 다음 항목을 넣으십시오.
ButtonObserver는 Key-Value Warning을 사용하여 제목 Label의 텍스트에 대한 변경을 UIButton을 관찰한다. 텍스트가 변경되면 값을 관찰하도록 콜백(forKeyPath:of:change:context:)이 수행된다. 이 물체는 제공된 XCTestExpectation을 유지하며 콜백에서 이를 충족한다.
다음으로 StepCountControllerTests.swift를 열고 // MARK 아래에 다음 테스트 도우미를 추가하십시오. - 언제:
StepCountControllerTests 테스트 빌드 및 실행 콘솔에서 몇 가지 오류를 확인하십시오.
테스트에서 Caught()와 Completed()를 호출할 때 버튼 제목이 업데이트되지 않는 이유는 아직 생산 코드에 후크가 없기 때문이다. StepCountController.swift에서 다음을 viewDidLoad에 추가하여 수정하십시오.

stateChangedCallback은 이제 모델에서 appState가 업데이트될 때 UI를 업데이트하는 데 사용된다. 이제 시험은 통과하고 넌 다음 단계로 넘어갈 준비가 됐어.
참고: 디버거에서 실행을 중지해도 대기 시간 제한이 일시 중지되지 않음 방금 코드를 여러 개 추가하셨는데, 실수가 있으면 다시 돌아가서 문제를 디버깅할 수도 있을 겁니다. 이것은 시험을 볼 때, 특히 시험들이 예상한 대로 행동하지 않을 때 흔하다. 디버거가 중단점에서 일시 중지되고 논리 오류를 탐색할 때 시간 초과로 인해 테스트가 실패할 수 있다는 점을 유념하십시오. 중단점을 비활성화하거나 제거하고 문제가 해결되면 다시 실행하십시오.


Waitng for notficatons
앱 구축의 다음 단계에서는 마일스톤 목표를 달성하거나 네시가 따라잡는 등 이벤트가 발생했을 때 사용자에게 시각적으로 알려주는 기능을 추가한다.
임의 콜백에서 기대치를 충족시키는 것 외에도, 테스트가 사용자 알림을 기다릴 수 있는 기능도 있다.


Building the alert center
활동 앱이나 게임의 한 가지 중요한 특징은 중요한 이벤트가 발생했을 때 사용자를 업데이트하는 것이다. FitNess에서 이러한 업데이트는 AlertCenter에 의해 관리된다. 흥미로운 일이 발생하면 코드는 AlertCenter에 알림을 게시할 것이다. 경보 센터는 사용자에게 표시할 메시지 스택을 관리할 책임이 있다.

AlertCenter는 알림을 사용하여 화면에서 알림을 처리하는 뷰 컨트롤러와 통신한다. 비동기적으로 발생하기 때문에 XCTestExpectation을 사용하여 테스트하는 것이 좋은 경우다.
AlertCenter 및 AlertCenterTests의 스텁한 구현이 프로젝트에 추가되어 작업 속도를 향상시켰다.
알림 동작을 테스트하려면 AlertCenterTests.swift에 다음 테스트를 추가하십시오.
기대(알림:목표:핸들러:)는 통지가 게시될 때 충족되는 기대를 생성한다. 이 경우 AlertNotification.name을 sut에 게시하면 그 기대가 충족된다. 그런 다음 테스트는 새 알림을 게시하고 해당 알림이 전송될 때까지 기다린다.
대기 시간을 시험 주장으로 사용하는 것은 일반적으로 좋은 생각이 아니라는 점에 유의하십시오. 명시적인 어설픈 호출을 사용하는 것이 좋다. 단지 기대가 충족되었는지 테스트만 하고 앱의 논리에 대해 어떠한 주장도 하지 않는다. 통지 내용은 이 장 뒷부분에서 테스트할 것이다.
만들고 시험해봐, 그러면 이 시험은 실패할 것이다. 콘솔에서 오류를 보면 시간 초과 실패가 나타난다.

이 문제를 해결하기 위해 응용 프로그램 코드를 구현할 시간! AlertCenter.swift에서 postAlert(경고:)의 스텁 구현을 다음으로 교체하십시오.

이렇게 하면 테스트가 수신 중인 알림을 만들고 게시할 수 있다. 전달된 경고는 현재 사용되지 않지만 나중에 이 항목으로 돌아가게 된다는 점에 유의하십시오.
구축 및 테스트. 그리고 시험은 통과할 것이다! :]


Waitng for multple events
그런 다음 두 개의 알림을 게시하면 두 개의 알림이 전송되는지 테스트해 보십시오. AlertCenterTests의 끝에 다음을 추가하십시오.
이로 인해 AlertNotification.name을 기다리는 두 가지 기대치가 생성되고, 두 가지 다른 경고를 게시하며, 두 가지 경고가 모두 통지될 때까지 기다린다.
건설하고 시험해 보면 통과될 거야. 하지만 이번 시험은 좀 순진하다. 방법을 보려면 다음 행을 삭제하십시오.

이제 당신은 기다림이 요구하는 기대와 관련된 두 가지 경고 중 하나만을 게시하고 있다.
다시 테스트해봐, 그러면 여전히 통과해! 두 기대가 같은 기대를 걸고 있기 때문이다. 그들은 병렬로 달린다. 쌓이지 않는다. 그래서 하나의 경고문이 게시되는 즉시 두 가지 기대치가 모두 충족된다.
이 문제를 해결하려면 알림 기대치를 사용하십시오.ProfessionalCount 속성은 이행 조건을 구체화한다. testPostingTwoAlerts_generateTwoNotification()을 다음으로 교체하십시오.

설정예상이행 카운트 2는 이행()이 시간 초과 전에 두 번 호출될 때까지 기대치가 충족되지 않음을 의미한다.
테스트를 실행하면 postAlert에 한 번만 전화를 걸었기 때문에 실패하는 것을 볼 수 있을 것이다. 이것은 너의 시험이 예상대로 효과가 있다는 좋은 증거다!
when 섹션에서 sut.postAlert(경고: alert1) 아래에 두 번째 사후 경보(postAlert)를 다시 추가하십시오.



테스트를 다시 실행하면 합격하는 것을 볼 수 있을 것이다.




Expecting something not to happen
좋은 테스트 스위트는 계획에 따라 일이 언제 일어나는지 테스트할 뿐만 아니라 특정 부작용이 발생하지 않는지 점검한다. 앱이 하지 말아야 할 것 중 하나는 경고로 사용자를 스팸 발송하는 것이다. 따라서 특정 경보를 두 번 게시할 경우 알림은 한 번만 생성해야 한다.
물론 이 시나리오에 대해 테스트해 볼 수도 있다. 다음 테스트를 추가하십시오.
기대가 반전되면 이 테스트가 실패하며 대기 시간이 초과되면 성공함을 나타낸다. 달리 말하면, 두 개의 경고에 의해 두 개의 알림이 트리거되는 경우 이 테스트는 실패한다.
현재 애플리케이션 코드는 여러 알림을 게시할 수 있기 때문에 테스트가 실패한다.
AlertCenter.swift를 여십시오. 다음 인스턴스 변수 추가: 

AlertQueue는 AlertCenter의 중요한 부분이 될 것이다. 사용자가 백그라운드로 누적될 수 있기 때문에 잠재적으로 많은 양의 메시지를 관리하는 데 도움이 될 것이다.
그런 다음 다음 다음 문장을 사후 경보(경고:

동일한 경보가 두 번 postAlert(경고:)에 전달되면 두 번째 경보가 무시된다.
구축하여 다시 테스트하십시오. 모두 녹색이요!
한 테스트에 대한 수정 사항이 다른 테스트에 영향을 미치지 않도록 모든 테스트를 수시로 실행하십시오.


Showing the alert to a user
앱의 아키텍처에서 루트뷰컨트롤러는 alertContainer 뷰를 통해 사용자에게 경고를 표시할 책임이 있다.
App Layer 폴더의 사례 아래에 새 Unit Test Case Class 파일을 만드십시오. 이름을 RootViewControllerTests.swift로 지정하십시오.
마지막으로 기본 조건에 대한 테스트를 추가하십시오. 즉, 뷰 컨트롤러가 로드될 때 다음과 같은 알림이 표시되지 않음:
이것을 실행하고 통과를 확인하십시오.
다음으로, 경고가 있을 때 경고 컨테이너가 표시되는지 테스트하려면 다음을 추가하십시오.
AlertNotification.name에 의해 기대가 충족될 것이며, 궁극적으로 알림을 트리거하기 위해 사후 Alert(경고:)가 호출된다. 기대치를 기다린 후 XCTAssertFalse는 alertContainer가 보이는지 점검한다.
